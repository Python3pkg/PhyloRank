#!/srv/sw/python/2.7.4/bin/python
###############################################################################
#                                                                             #
#    This program is free software: you can redistribute it and/or modify     #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License, or        #
#    (at your option) any later version.                                      #
#                                                                             #
#    This program is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#                                                                             #
#    You should have received a copy of the GNU General Public License        #
#    along with this program. If not, see <http://www.gnu.org/licenses/>.     #
#                                                                             #
###############################################################################

__author__ = "Donovan Parks"
__copyright__ = "Copyright 2015"
__credits__ = ["Donovan Parks"]
__license__ = "GPL3"
__maintainer__ = "Donovan Parks"
__email__ = "donovan.parks@gmail.com"
__status__ = "Development"

import os
import sys
import json
import argparse

from phylorank.main import OptionsParser
from biolib.misc.custom_help_formatter import CustomHelpFormatter


def version():
    """Read program version from file."""
    bin_dir = os.path.dirname(os.path.realpath(__file__))
    version_file = open(os.path.join(bin_dir, '..', 'phylorank', 'VERSION'))
    return version_file.read().strip()


def print_help():
    """Help menu."""

    print ''
    print '                ...::: PhyloRank v' + version() + ' :::...'''
    print '''\

  decorate    -> Decorate nodes with inferred taxonomic ranks.
  dist_plot   -> Plot distribution of groups in each taxonomic rank.

  pull        -> Pull taxonomy information from tree.
  validate    -> Validate consistency of taxonomy.
  append      -> Append taxonomy to extant tree labels.
  taxon_stats -> Summary statistics of taxonomic groups.


  [Expert commands: hide these at some point]

  robustness_plot -> Plot relative distance of groups across a set of trees.


  Use: phylorank <command> -h for command specific help.

  Feature requests or bug reports can be sent to Donovan Parks (donovan.parks@gmail.com)
    or posted on GitHub (https://github.com/dparks1134/autorank).
    '''

if __name__ == '__main__':

    # initialize the options parser
    parser = argparse.ArgumentParser(add_help=False)
    subparsers = parser.add_subparsers(help="--", dest='subparser_name')

    # decorate nodes with inferred taxonomic ranks
    decorate_parser = subparsers.add_parser('decorate',
                                            formatter_class=CustomHelpFormatter,
                                            description='Decorate nodes with inferred taxonomic ranks')

    decorate_parser.add_argument('input_tree', help="input tree to decorate")
    decorate_parser.add_argument('output_tree', help="output tree with assigned taxonomic ranks")
    decorate_parser.add_argument('-t', '--thresholds', help="relative divergence thresholds for taxonomic ranks", type=json.loads,
                                    default='{"d": 0.33, "p": 0.56, "c": 0.65, "o": 0.78, "f": 0.92, "g": 0.99}')
    decorate_parser.add_argument('-s', '--min_support', help="only decorate nodes above the specified support value", type=float, default=0)
    decorate_parser.add_argument('-n', '--only_named_clades', help="only decorate nodes with an existing label", action='store_true')
    decorate_parser.add_argument('-l', '--min_length', help="only decorate nodes with a parent branch above the specified length", type=float, default=0.0)

    # pull taxonomy strings from tree
    pull_parser = subparsers.add_parser('pull',
                                            formatter_class=CustomHelpFormatter,
                                            description='Pull taxonomy information from tree.')

    pull_parser.add_argument('input_tree', help="input tree to extract taxonomy from")
    pull_parser.add_argument('output_file', help="file to contain taxonomy strings for each extant taxon")
    pull_parser.add_argument('--no_rank_fill', action="store_true", help="do not automatically fill in missing ranks")

    # validate consistency of taxonomy
    validate_parser = subparsers.add_parser('validate',
                                            formatter_class=CustomHelpFormatter,
                                            description='Validate consistency of taxonomy.')

    validate_parser.add_argument('taxonomy_file', help="file with taxonomy for extant taxa")
    validate_parser.add_argument('--no_prefix', action="store_true", help="do not check taxon prefixes")
    validate_parser.add_argument('--no_all_ranks', action="store_true", help="do not check for the presence of all ranks")
    validate_parser.add_argument('--no_hierarhcy', action="store_true", help="do not check for inconsistencies in the taxonomic hierarchy")
    validate_parser.add_argument('--no_species', action="store_true", help="do not check for hierarchical inconsistencies with named species")

    # append taxonomy to extant tree labels
    append_parser = subparsers.add_parser('append',
                                            formatter_class=CustomHelpFormatter,
                                            description='Append taxonomy to extant tree labels.')

    append_parser.add_argument('input_tree', help="input tree to decorate")
    append_parser.add_argument('taxonomy_file', help="file with taxonomy for extant taxa")
    append_parser.add_argument('output_tree', help="output tree with taxonomy appended to extant taxon labels")

    # summary statistics of taxonomic groups
    taxon_stats_parser = subparsers.add_parser('taxon_stats',
                                            formatter_class=CustomHelpFormatter,
                                            description='Summary statistics of taxonomic groups.')

    taxon_stats_parser.add_argument('taxonomy_file', help="file with taxonomy for extant taxa")
    taxon_stats_parser.add_argument('output_file', help="output file with summary statistics")

    # plot relative distance of groups across a set of trees.
    robustness_plot_parser = subparsers.add_parser('robustness_plot',
                                            formatter_class=CustomHelpFormatter,
                                            description='Plot relative distance of groups across a set of trees')

    robustness_plot_parser.add_argument('rank', help="taxonomic rank of named groups to plot", type=int, choices=[1, 2, 3, 4, 5, 6])
    robustness_plot_parser.add_argument('input_tree_dir', help="directory containing trees to inferred relative distance across")
    robustness_plot_parser.add_argument('full_tree_file', help="unmodified tree to include in plot; must be decorate with taxonomy")
    robustness_plot_parser.add_argument('derep_tree_file', help="dereplicated tree to include in plot")
    robustness_plot_parser.add_argument('taxonomy_file', help="file indicating taxonomy string for each genome")
    robustness_plot_parser.add_argument('output_prefix', help="output prefix for generated files")
    robustness_plot_parser.add_argument('-m', '--min_children', help='minimum named child taxa to consider taxa', type=int, default=2)
    robustness_plot_parser.add_argument('-t', '--title', help='title of plot', default=None)

    # plot distribution of groups in each taxonomic rank
    dist_plot_parser = subparsers.add_parser('dist_plot',
                                            formatter_class=CustomHelpFormatter,
                                            description='Plot distribution of groups in each taxonomic rank')

    dist_plot_parser.add_argument('input_tree', help="directory containing trees to inferred relative distance across")
    dist_plot_parser.add_argument('output_prefix', help="output prefix for generated files")
    dist_plot_parser.add_argument('-m', '--min_children', help='minimum named child taxa to consider taxa', type=int, default=2)
    dist_plot_parser.add_argument('-s', '--min_support', help="only decorate nodes above the specified support value", type=float, default=0)
    dist_plot_parser.add_argument('-t', '--title', help='title of plot', default=None)

    # get and check options
    args = None
    if(len(sys.argv) == 1 or sys.argv[1] == '-h' or sys.argv == '--help'):
        print_help()
        sys.exit(0)
    else:
        args = parser.parse_args()

    # do what we came here to do
    try:
        parser = OptionsParser()
        if(False):
            # import pstats
            # p = pstats.Stats('prof')
            # p.sort_stats('cumulative').print_stats(10)
            # p.sort_stats('time').print_stats(10)
            import cProfile
            cProfile.run('parser.parse_options(args)', 'prof')
        elif False:
            import pdb
            pdb.run(parser.parse_options(args))
        else:
            parser.parse_options(args)
    except SystemExit:
        print "\n  Controlled exit resulting from an unrecoverable error or warning."
    except:
        print "\nUnexpected error:", sys.exc_info()[0]
        raise
